1. Смотрим логи.
   Включение профилирования - db.setProfilingLevel()
   Устанавливаем уровень профирирования - db.setProfilingLevel(1, { slowms: 180000 })
   Ищем журнал запросов с более чем 180000 милисекунд db.system.profile.find( {millis : { $gt : 180000 } } ).sort( { ts: 1} );
      
   Так же можно получить текущий идентификатор операции с помощью db.currentOp()
   Убить opp через db.killOp(<opId>)

2. Смотрим логи.
   Проблема в существующем медленном запросе, а по скольку Redis однопоточный, то пока команда запущена, 
   никакая другая команда не может быть выполнена.

3.  Причина возможно в большом объеме данных и СУБД необходимо больше времени на обработку запросов. Смотрим логи.
    Смотрим, какие значения используются сейчас net_read_timeout, net_write_timeout.
    show global variables like '%timeout';
    Увеличим net_read_timeout, net_write_timeout с его значения по умолчанию 30 и 60 секунд.
    Если не помогло, то может быть причиной поврежденные innnodb таблицы. 
    Попробовать установить опцию innodb_force_recovery = 1

4.  Когда заканчивается память, вызывается функция out_of_memory(). Out Of Memory Killer — это процесс, который завершает приложение, 
    чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС. Проблема нехватки памяти.
    Решение: увеличить оперативную память и изменить конфигурационный файл, либо добавить swap.
